---
title: "Econ 144 Project 2"
author: "Shannan Liu, Austin Pham, Zach Wrubel"
date: "`r format(Sys.time(), '%d %B, %Y')`"
fontfamily: mathpazo
output:
  pdf_document:
    toc: true
  fig_caption: yes
  highlight: haddock
  number_sections: true
  df_print: paged
fontsize: 10.5pt
editor_options:
chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
library(tseries)
library(forecast)
library(stats)
library(stats4)
library(TSA)
library(timeSeries)
library(fUnitRoots)
library(fBasics)
library(tseries)
library(timsac)
library(TTR)
library(strucchange)
library(tis)
library(zoo)
library(gridExtra)
library(crypto2)
library(ggplot2)
library(PerformanceAnalytics)
library(tibble)
library(vars)
library(MLmetrics)
```

\newpage
# I. Introduction  

In this project, we will forecast the returns of Bitcoin with several models including ARIMA, ETS, Holt-Winters, NNETAR, Prophet, and a forecast combination.

To build these forecasts, we'll also be using data from other cryptocurrencies including Ethereum, Tether, and XRP.  


## Brief Background on Data:
Bitcoin (BTC): a digital currency that was released on Jan 3, 2009. It is the most well known cryptocurrency in the world, and it popularised the concept of blockchain technology. While some countries have adopted it as legal tender, others such as China, have banned the currency from their country. Although Bitcoin can be used to purchase goods and services, many view it as an investment vehicle because of its meteoric rise in value. Some investors also believe it could replace gold as a safe-haven investment during periods of high inflation or economic uncertainty.   

Ethereum (ETH): another digital currency. It was released on July 30, 2015. It is the next most popular cryptocurrency. It introduced smart contract functionality, which Bitcoin does not have.   

Tether (USDT): unlike Bitcoin and Ethereum, Tether is a stable coin, meaning its value is pegged to the US dollar at a 1:1 ratio. Thus, its value is more stable than other cryptocurrecies.  

XRP: is another popular cryptocurrency created by Ripple and mainly used for the settlement of cross-border remittances. 

## Source of Data
All of the data was sourced from https://coinmarketcap.com via their web api. We will be analyzing daily observations of the data from December 20, 2015 to March 3, 2022. Company descriptions were adapted from descriptions provided at https://bloomberg.com.


```{r warning=FALSE}
# import data
# get list of active coins from 2015
cl <- crypto_list(only_active=TRUE) %>%
  dplyr::filter(first_historical_data<="2015-12-31",
                last_historical_data>="2022-03-03")

cl_final <- rbind(dplyr::filter(cl,cl$slug=="bitcoin"),
                  dplyr::filter(cl,cl$slug=="ethereum"),
                  dplyr::filter(cl,cl$slug=="xrp"),
                  dplyr::filter(cl,cl$slug=="tether"))

coins <- crypto_history(coin_list = cl_final,
                        start_date = "20151231", interval="daily")

relevant_vars <- c("timestamp","close","volume",
                   "open","high","low","market_cap")

# create separate dfs for each variable
btc <- dplyr::filter(coins[relevant_vars],coins$slug=="bitcoin")
eth <- dplyr::filter(coins[relevant_vars],coins$slug=="ethereum")
usdt <- dplyr::filter(coins[relevant_vars],coins$slug=="tether")
xrp <- dplyr::filter(coins[relevant_vars],coins$slug=="xrp")

# convert POSIXct to date time
btc$timestamp <- as.Date(btc$timestamp)
eth$timestamp <- as.Date(eth$timestamp)
usdt$timestamp <- as.Date(usdt$timestamp)
xrp$timestamp <- as.Date(xrp$timestamp)

# there are no NA values 
cat("Number of NA values in BTC series:",sum(is.na(btc)),"\n")
cat("Number of NA values in ETH series:",sum(is.na(eth)),"\n")
cat("Number of NA values in USDT series:",sum(is.na(usdt)),"\n")
cat("Number of NA values in XRP series:",sum(is.na(xrp)))

# create returns column 
btc$returns <- c(NA,diff(log(btc$close)))
eth$returns <- c(NA,diff(log(eth$close)))
usdt$returns <- c(NA,diff(log(usdt$close)))
xrp$returns <- c(NA,diff(log(xrp$close)))

# remove NAs
btc <- na.omit(btc)
eth <- na.omit(eth)
usdt <- na.omit(usdt)
xrp <- na.omit(xrp)

btc_ts <- ts(btc$returns,
             # daily freq
             frequency = 365,
             start = c(2016,1))
eth_ts <- ts(eth$returns,
             # daily freq
             frequency = 365,
             start = c(2016,1))
usdt_ts <- ts(usdt$returns,
             # daily freq
             frequency = 365,
             start = c(2016,1))
xrp_ts <- ts(xrp$returns,
             # daily freq
             frequency = 365,
             start = c(2016,1))
```

\newpage
# II. Results  

## (A) Time Series Plots
```{r warning=FALSE}
library(glue)
tsplot <- function(y,series_name) {
  #################################
  # Plot the original time series 
  # A histogram of the series     
  # ACF and PACF plots
  #################################
  ax1 = autoplot(y, main = sprintf("%s Returns",series_name),
         ylab = "Percentage (%)",xlab = "Time")
  `Closing Price` = y
  ax2 = gghistogram(`Closing Price`)
  ax3 = ggAcf(y,
              main = glue('{series_name} Sample Autocorrelations'),
              xlab="Displacement",lag.max = 48)
  ax4 = ggPacf(y,
               main = glue('{series_name} Sample Partial Autocorrelations'),
               xlab="Displacement",lag.max = 48)
  grid.arrange(ax1, ax2,ax3,ax4, ncol=2,nrow = 2)
}

# plot returns together together
returns <- data.frame(btc_ts,eth_ts,usdt_ts,xrp_ts)
rownames(returns) <- btc$timestamp
head(returns)
chart.TimeSeries(returns, 
      legend.loc="bottom", 
      main="Daily Returns of BTC, ETH, USDT,XRP",) 

# plot returns separately:
# time-series, histogram, ACF and PACF plots 
tsplot(btc_ts,"BTC")
tsplot(eth_ts,"ETH")
tsplot(usdt_ts,"USDT")
tsplot(xrp_ts,"XRP")
```

From the first graph of all the returns series, we can see that XRP has had the highest volatility. Meanwhile, USDT has the most stable returns.

In the individual plots, we observe that the returns data for all the cryptocurrencies look stationary and that they have ACFs and PACFs that resemble white noise. Therefore, they may not be useful as regressors. This also indicates that it may be difficult to model BTC's returns over time. However, non-linear relationships between the lags of BTC's returns do exist (as shown below). Thus, it may be worthwhile to attempt to model this data.

```{r warning=FALSE}
tsplot(btc_ts^2,"BTC^2")
tsplot(abs(btc_ts),"Absolute value of BTC")
```

## (B) Relationship between BTC's returns and other variables   
We'll utilise a scatterplot matrix and correlation plot to visualize the relationships between all of the currencies' returns.
```{r}
library(GGally)
ret_data <- data.frame(btc$returns,eth$returns,
                       usdt$returns,xrp$returns)

# scatterplot
ggpairs(ret_data)
```

The scatterplot matrix shows that BTC, ETH, and XRP have moderately positive correlations with each other, suggesting that they may be useful regressors for modelling BTC's returns.

```{r}
# how much do BTC's returns correlate with 
# its own data (e.g. BTC's OLHC)
self_data <- data.frame(btc$returns,btc$volume,
                        btc$open,btc$low,btc$high,
                        btc$close,btc$market_cap)

# scatterplot
ggcorr(self_data)
```

There is very little correlation between BTC's returns and other data about it.

```{r}
# BTC returns and ETH data
eth_data <- data.frame(btc$returns,eth$volume,
                       eth$open,eth$low,eth$high,
                       eth$close,eth$market_cap,
                       eth$returns)

# scatterplot
ggcorr(eth_data)
```
ETH's returns is the only variable that is positively linearly correlated with BTC's returns.

```{r}
# BTC returns and USDT data
usdt_data <- data.frame(btc$returns,usdt$volume,
                       usdt$open,usdt$low,usdt$high,
                       usdt$close,usdt$market_cap,
                       usdt$returns)

# scatterplot
ggcorr(usdt_data)
```

There is no correlation between BTC's returns and USDT's data

```{r}
# BTC returns and ETH data
xrp_data <- data.frame(btc$returns,xrp$volume,
                       xrp$open,xrp$low,xrp$high,
                       xrp$close,xrp$market_cap,
                       xrp$returns)

# scatterplot
ggcorr(xrp_data)
```
XRP's returns is the only variable that is positively linearly correlated with BTC's returns.

From this, we can conclude that XRP's and ETH's returns are potentially appropriate regressors for forecasting BTC's returns, and we can incorporate them into our models.

## (C) Can BTC's returns be decomposed?  
```{r}
autoplot(stl(btc_ts,s.window = "periodic",robust=TRUE),
     main = "BTC STL Decomposition")
```

The plot shows a trend, but the trend's magnitude is so small that it can be considered insignificant. There may be a seasonal pattern in the data that can be exploited, as it appears that there are regular periods of higher volatility. There also appears to be some structure in the residuals.

To affirm or reject these observations, we can build several models and test their significance.

## (D) Fitting ARIMA to BTC's returns  
We will fit an ARIMA to BTC's returns in two ways. First, we will use an ARIMA to model the data itself. Second, we will fit a regression to the data and fit the ARIMA to the regression model's errors.
```{r}
btc_tib <- as_tibble(btc)

arima_btc <- auto.arima(btc_ts)
reg_arima_btc <- auto.arima(btc_tib[,"returns"],
                 xreg=cbind(eth$returns,
                            xrp$returns))
summary(arima_btc)
summary(reg_arima_btc)
```

For the pure ARIMA model, we obtain a ARIMA(0,0,0) process with non-zero mean. This suggests that the ARIMA process is not suitable for modeling this data.

In the second model, we fit a regression to the returns data and obtain a ARIMA (0,0,1) to model our errors. Since the data was already covariance stationary, there was no need for differencing it. Thus, I = 0. The lack of an AR(1) process suggests that the errors do not have persistent autocorrelations. There is also no seasonality or trend captured by the model.

The second model lower AIC, AICc, and BIC. Therefore, it is better than the simpler ARIMA model.

## (E) Plot ACF and PACF of residuals
```{r}
ggtsdisplay(resid(arima_btc),
            main = "Pure ARIMA Model Residuals",
            ylab = "Percentage")
```

The residuals of the pure ARIMA model do not show very much structure. However, this doesn't mean that the ARIMA is a good model for forecasting the data because it would only predict the mean value of the series at future points in time.

```{r}
ggtsdisplay(resid(reg_arima_btc),
            main = "Regression + ARIMA Residuals",
            ylab = "Percentage")
```

The plot of the residuals appears to retain some structure which can be modeled. However, the magnitude of the autocorrelation spikes seen on the ACF and PACF plots suggest that this structure may not be very significant. Therefore, the regression + ARIMA model fits the data quite well.

## (F) Plot regression-ARIMA fit and residuals vs. fitted-values

```{r}
# plot of fitting values
reg_arima_fit <- ts(reg_arima_btc$fitted,frequency = 365,
               start = c(2016,1))


autoplot(cbind(btc_ts,reg_arima_fit),
         main = "Regression + ARIMA Fit") +
  labs("Series","Fit")
```

```{r}
# plot of residuals vs. fitted values
library(ggplot2)
plot_resid_fit <- function(x,y,title) {
  data = data.frame(x = x, y = y)

  p <- ggplot(data, aes(x =  x, y = y)) +
    geom_smooth(method = "lm", se=T,
                col = "red",
                formula = y ~ x,
                show.legend = T) + 
    geom_point(alpha = 0.5,size = 2,
               col = "black") +
    xlab("Fit") + ylab("Residuals") +
    ggtitle(glue("{title} Residuals vs Fit"))
    
  return(p)
}
plot_resid_fit(fitted(reg_arima_btc),
               resid(reg_arima_btc),"BTC")
```

There is not much of a linear relationship between the fit and the residuals, suggesting that our model's fit did pretty well. We will now look at the recursive residuals to further reaffirm this conclusion. 

## Plot the recursive residuals 

```{r}
#Plot recursive residuals 
reg_arima_btc_recresid = recresid(reg_arima_btc$residuals~1)
plot(reg_arima_btc_recresid, ylab="Regression + Arima Fit",
     main="Recursive Residuals from Regression + Arima Fit")
```

The recursive residuals are scattered around 0 and do not show any dynamics, reaffirming that the Regression + Arima Fit is a good model. 
## Train and Test Regression + Arima Fit to get MAPE

```{r}

```

## Compare your forecast from (i) to the 12-steps ahead forecasts from Holt-Winters, ETS, NNETAR, VAR, Prophet  

We will now construct a Holt-Winters model and assess whether it outperforms our Regression + arima fit.

### Holt-Winters

Due to the high frequency of the data, we will create a Holt-Winters model consisting of a linear regression + additive Holt-Winters for the residuals. 

```{r}
#Create linear regression of btc returns on eth returns
btc_eth_lm <- lm(btc$returns~eth$returns)
btc_lm_res_ts <- ts(btc_eth_lm$residuals,freq=365,start=c(2016,1))
reg_hw_btc <- hw(btc_lm_res_ts,seasonal=c("additive"))
reg_ets_btc <- ets(btc_lm_res_ts)
```


### NNETAR Models

We will fit a NNETAR model to BTC Returns, as well as a NNETAR model consisting of a linear model of BTC Returns regressed on ETH Returns and a NNETAR model of the residuals.

```{r}
#NNAR model of BTC returns
nnar_btc <- nnetar(btc_ts)

#Linear model with NNAR model of residuals
btc_eth_lm <- lm(returns$btc~returns$eth_ts)
reg_nnar_btc <- nnetar(btc_eth_lm$residuals, 
                       xreg=cbind(returns$btc_ts,returns$eth_ts))

#Plot both NNAR models 
autoplot(btc_ts, series="BTC Returns") +
  autolayer(nnar_btc$fitted, series="NNAR Model Returns") +
  autolayer(reg_nnar_btc$fitted, series="LM of Returns + NNAR Model of Residuals") +
  ggtitle("NNAR Model Fits for BTC Returns")
```

Judging from the plot, the Linear Model + NNETAR Model appears to outperform the simple NNETAR model. We will now look at the residuals from each in order to choose a model. 

##Inspect residuals from both nnetar fits

```{r}
checkresiduals(nnar_btc, main="Residuals from NNETAR Model of BTC Returns")
checkresiduals(reg_nnar_btc$residuals, main="Residuals from Linear Model with NNETAR Model of Residuals")
```

The residuals for both models appear to be white noise and normally distributed, but the magnitude of the lags for the Linear Model + NNETAR model are significantly lower and display less dynamics. Therefore, we will create our forecasts with the Linear Model + NNETAR Model. 

#Inspect Recursive Residuals
```{r}
reg_nnar_btc_recresid = recresid(reg_nnar_btc$residuals~1)
plot(reg_nnar_btc_recresid,ylab="Regression + NNETAR Fit", 
     main="Recursive Residuals from Regression + NNETAR fit")
```

The recursive residuals from the Regression + NNETAR model reaffirm that this model is a good fit. Thus, we will continue and forecast with this fit. 

#Train and Test to get MAPE from Regression + NNETAR Model

```{r}
btc.train <- window(btc_ts, end=c(2021,1))
eth.train <- window(eth_ts, end=c(2021,1))
btc.eth.lm.train <- lm(btc.train ~ eth.train)
reg.nnar.train <- nnetar(btc.eth.lm.train$residuals,
                         xreg=cbind(btc.train,eth.train))
reg.nnar.pred <- predict(object=reg.nnar.train$fitted, n.ahead=12) #Need to figure this out
MAPE(btc.train, reg.nnar.pred$model$fitted.values)
```

### VAR -- ETH, XRP & BTC since they are correlated

We will now create VAR models to see if we can outperform our Regression + NNETAR Model. We will create two VAR models: one between BTC and ETH, and one between BTC and XRP. First we will start with a BTC and ETH VAR Model.

## BTC and ETH VAR Model 

```{r}
#Explore cross-correlations
ccf(btc_ts,eth_ts,ylab="Cross-Correlation Function", main = "BTC and ETH CCF")

#Create combined sample for VAR model 
y_btc_eth=cbind(btc_ts, eth_ts)
y_tot_btc_eth=data.frame(y_btc_eth)
VARselect(y_tot_btc_eth, lag.max = 10)
```

From VARselect, we will set the oder p=4 for our VAR model. 

# Create VAR model for BTC and ETH
```{r}
vmod_btc_eth=VAR(y_btc_eth,p=4) 
summary(vmod_btc_eth) 
```

We will now inspect the residuals to measure the fit.

#Inspect Residuals
```{r}
vmod_btc_eth$varresult$btc_ts
tsdisplay(vmod_btc_eth$varresult$btc_ts$fitted.values)
tsdisplay(vmod_btc_eth$varresult$btc_ts$residuals)
```
The residuals appear to be mostly scattered around 0 with very little dynamics. Thus, this VAR model appears to be a good fit so far.

#Plot VAR Model
```{r}
vmod_eth_ts = ts(vmod_btc_eth$varresult$btc_ts$fitted.values,
                 start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1,main="BTC Returns and Fitted Values from BTC,ETH VAR Model")
lines(vmod_eth_ts,col="red",lty=2)
legend("bottomleft",legend=c("BTC","VAR"),text.col=1:4,bty = "o")
```
While the residuals appeared to resemble white noise, it is apparent that our VAR model using ETH returns does not capture a large portion of the volatility in BTC returns. We will now try to create another VAR model using XRP returns to forecast BTC returns. 

## BTC and XRP VAR Model 

```{r}
#Explore cross-correlations
ccf(btc_ts,xrp_ts,ylab="Cross-Correlation Function", main = "BTC and XRP CCF")

#Create combined sample for VAR model 
y_btc_xrp=cbind(btc_ts,xrp_ts)
y_tot_btc_xrp=data.frame(y_btc_xrp)
VARselect(y_btc_xrp, lag.max=10)
```

From VARselect we will choose order p=2 for our VAR model.

```{r}
#Create VAR model for BTC and XRP
vmod_btc_xrp=VAR(y_btc_xrp,p=2)
summary(vmod_btc_xrp)
```

#Inspect Residuals
```{r}
vmod_btc_xrp$varresult$btc_ts
tsdisplay(vmod_btc_xrp$varresult$btc_ts$fitted.values)
tsdisplay(vmod_btc_xrp$varresult$btc_ts$residuals)
```

These residuals also appear to resemble white noise with very little dynamics that do not appear to be significant. Once again we will move forward with this model since the residuals suggest this VAR model is a good fit. 

#Plot Model 
```{r}
vmod_xrp_ts = ts(vmod_btc_xrp$varresult$btc_ts$fitted.values,
                 start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1,main="BTC Returns and Fitted Values from BTC,XRP VAR Model")
lines(vmod_xrp_ts,col="red",lty=2)
legend("bottomleft",legend=c("BTC","VAR"),text.col=1:4,bty = "o")
```

As with the orevious VAR model, the VAR model using ETH returns do not seem to capture any of the volatility in the BTC returns series. We will now train and test each VAR model (the first one using ETH returns and the second using XRP returns) in order to measure the MAPE to decide which VAR model performs better in predicting BTC returns. We will then compare this chosen model to our previous models to assess if we can outperfrom them.

#Train and test to measure MAPE for both VAR models
```{r}
#Train and test ETH VAR Model
btc.train <- window(btc_ts, end=c(2021,1))
eth.train <- window(eth_ts, end=c(2021,1))
y.eth.train=cbind(btc.train,eth.train)
y_eth_train=data.frame(y.eth.train)
vmod.eth.train=VAR(y_eth_train,p=4)
vmod.eth.train.pred=predict(object=vmod.eth.train, n.ahead=12)

#Train and test XRP VAR Model
xrp.train <- window(xrp_ts, end=c(2021,1))
y.xrp.train=cbind(btc.train,xrp.train)
y_xrp_train=data.frame(y.xrp.train)
vmod.xrp.train=VAR(y_xrp_train,p=2)
vmod.xrp.train.pred=predict(object=vmod.xrp.train, n.ahead=12)

#Compare MAPEs
MAPE(vmod.eth.train.pred$model$varresult$btc.train$fitted.values, y_eth_train$btc.train)
MAPE(vmod.xrp.train.pred$model$varresult$btc.train$fitted.values, y_xrp_train$btc.train)
```

Our VAR model using ETH returns to predict BTC returns has a significantly lower MAPE, so we will forecast with this model. 

#Forecast 12 steps ahead using ETH VAR Model 

```{r}
vmod.pred <- predict(object=vmod_btc_eth, n.ahead=12)
plot(vmod.pred, xlim=c(2000,2500))
```

### Prophet Model
```{r}
# can add regressors & change points if you want.. up to you
library(prophet)
df_r_btc <- data.frame(ds = btc$timestamp,
                 y = as.numeric(btc$returns))

preds_btc <- prophet(df_r_btc,daily.seasonality=TRUE)
future_btc <- make_future_dataframe(preds_btc, periods = 60)
forecast_btc <- predict(preds_btc, future_btc)

plot(preds_btc, 
     forecast_btc,
     main="BTC Returns",
     ylab = "Percentage",
     xlab = "Time")

#can try using this too if u want to interpret stuff
#prophet_plot_components()
#plot_cross_validation_metric()
```


###THIEF

###TBATS

###Combined Forecasts

## Combine the forecasts + discussion on MAPE from this forecasts vs., the individual ones  

```{r}

```

## Financial performance of models (sample)  & interpretation
```{r}
# if hits == -1, then model predicted in wrong direction
# if hits == 1, then model predicted in correct direction
hits=sign(fitted(reg_arima_btc)*btc$returns)
cat("Correct predictions",length(hits[hits == 1]),"\n")
cat("Incorrect predictions",length(hits[hits == -1]),"\n")
cat("Hit ratio",length(hits[hits == 1])/length(hits))

# our model's returns
strat_ret = ts(cumsum(sign(fitted(reg_arima_btc))*btc$returns),
                   start = c(2016,1),
                   frequency = 365)
# returns of longing instrument
norm_ret = ts(cumsum(btc_ts),start = c(2016,1),
              frequency = 365)
autoplot(cbind(exp(norm_ret),exp(strat_ret)))
```

# Conclusion

#Make sure to exlpain why we did not use HW / ETS because they were not built for this high of frequency data and crashed our Rstudio so we supplemented with THIEF / MAPAS / TBATS

