) %>%
forecast(h = 1) %>%
accuracy(btc)
btc_eth_lm <- lm(btc$returns~eth$returns)
btc_eth_lm <- lm(btc$returns~eth$returns)
#Create linear regression of btc returns on eth returns
btc_eth_lm <- lm(btc$returns~eth$returns)
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
library(tseries)
library(forecast)
library(stats)
library(stats4)
library(TSA)
library(timeSeries)
library(fUnitRoots)
library(fBasics)
library(tseries)
library(timsac)
library(TTR)
library(strucchange)
library(tis)
library(zoo)
library(gridExtra)
library(crypto2)
library(ggplot2)
library(PerformanceAnalytics)
library(tibble)
# import data
# get list of active coins from 2015
cl <- crypto_list(only_active=TRUE) %>%
dplyr::filter(first_historical_data<="2015-12-31",
last_historical_data>="2022-03-03")
cl_final <- rbind(dplyr::filter(cl,cl$slug=="bitcoin"),
dplyr::filter(cl,cl$slug=="ethereum"),
dplyr::filter(cl,cl$slug=="xrp"),
dplyr::filter(cl,cl$slug=="tether"))
coins <- crypto_history(coin_list = cl_final,
start_date = "20151231", interval="daily")
relevant_vars <- c("timestamp","close","volume",
"open","high","low","market_cap")
# create separate dfs for each variable
btc <- dplyr::filter(coins[relevant_vars],coins$slug=="bitcoin")
eth <- dplyr::filter(coins[relevant_vars],coins$slug=="ethereum")
usdt <- dplyr::filter(coins[relevant_vars],coins$slug=="tether")
xrp <- dplyr::filter(coins[relevant_vars],coins$slug=="xrp")
# convert POSIXct to date time
btc$timestamp <- as.Date(btc$timestamp)
eth$timestamp <- as.Date(eth$timestamp)
usdt$timestamp <- as.Date(usdt$timestamp)
xrp$timestamp <- as.Date(xrp$timestamp)
# there are no NA values
cat("Number of NA values in BTC series:",sum(is.na(btc)),"\n")
cat("Number of NA values in ETH series:",sum(is.na(eth)),"\n")
cat("Number of NA values in USDT series:",sum(is.na(usdt)),"\n")
cat("Number of NA values in XRP series:",sum(is.na(xrp)))
# create returns column
btc$returns <- c(NA,diff(log(btc$close)))
eth$returns <- c(NA,diff(log(eth$close)))
usdt$returns <- c(NA,diff(log(usdt$close)))
xrp$returns <- c(NA,diff(log(xrp$close)))
# remove NAs
btc <- na.omit(btc)
eth <- na.omit(eth)
usdt <- na.omit(usdt)
xrp <- na.omit(xrp)
btc_ts <- ts(btc$returns,
# daily freq
frequency = 365,
start = c(2016,1))
eth_ts <- ts(eth$returns,
# daily freq
frequency = 365,
start = c(2016,1))
usdt_ts <- ts(usdt$returns,
# daily freq
frequency = 365,
start = c(2016,1))
xrp_ts <- ts(xrp$returns,
# daily freq
frequency = 365,
start = c(2016,1))
library(glue)
tsplot <- function(y,series_name) {
#################################
# Plot the original time series
# A histogram of the series
# ACF and PACF plots
#################################
ax1 = autoplot(y, main = sprintf("%s Returns",series_name),
ylab = "Percentage (%)",xlab = "Time")
`Closing Price` = y
ax2 = gghistogram(`Closing Price`)
ax3 = ggAcf(y,
main = glue('{series_name} Sample Autocorrelations'),
xlab="Displacement",lag.max = 48)
ax4 = ggPacf(y,
main = glue('{series_name} Sample Partial Autocorrelations'),
xlab="Displacement",lag.max = 48)
grid.arrange(ax1, ax2,ax3,ax4, ncol=2,nrow = 2)
}
# plot returns together together
returns <- data.frame(btc_ts,eth_ts,usdt_ts,xrp_ts)
rownames(returns) <- btc$timestamp
head(returns)
chart.TimeSeries(returns,
legend.loc="bottom",
main="Daily Returns of BTC, ETH, USDT,XRP",)
# plot returns separately:
# time-series, histogram, ACF and PACF plots
tsplot(btc_ts,"BTC")
tsplot(eth_ts,"ETH")
tsplot(usdt_ts,"USDT")
tsplot(xrp_ts,"XRP")
tsplot(btc_ts^2,"BTC^2")
tsplot(abs(btc_ts),"Absolute value of BTC")
library(GGally)
ret_data <- data.frame(btc$returns,eth$returns,
usdt$returns,xrp$returns)
# scatterplot
ggpairs(ret_data)
# how much do BTC's returns correlate with
# its own data (e.g. BTC's OLHC)
self_data <- data.frame(btc$returns,btc$volume,
btc$open,btc$low,btc$high,
btc$close,btc$market_cap)
# scatterplot
ggcorr(self_data)
# BTC returns and ETH data
eth_data <- data.frame(btc$returns,eth$volume,
eth$open,eth$low,eth$high,
eth$close,eth$market_cap,
eth$returns)
# scatterplot
ggcorr(eth_data)
# BTC returns and USDT data
usdt_data <- data.frame(btc$returns,usdt$volume,
usdt$open,usdt$low,usdt$high,
usdt$close,usdt$market_cap,
usdt$returns)
# scatterplot
ggcorr(usdt_data)
# BTC returns and ETH data
xrp_data <- data.frame(btc$returns,xrp$volume,
xrp$open,xrp$low,xrp$high,
xrp$close,xrp$market_cap,
xrp$returns)
# scatterplot
ggcorr(xrp_data)
autoplot(stl(btc_ts,s.window = "periodic",robust=TRUE),
main = "BTC STL Decomposition")
btc_tib <- as_tibble(btc)
arima_btc <- auto.arima(btc_ts)
reg_arima_btc <- auto.arima(btc_tib[,"returns"],
xreg=cbind(eth$returns,
xrp$returns))
summary(arima_btc)
summary(reg_arima_btc)
ggtsdisplay(resid(arima_btc),
main = "Pure ARIMA Model Residuals",
ylab = "Percentage")
ggtsdisplay(resid(reg_arima_btc),
main = "Regression + ARIMA Residuals",
ylab = "Percentage")
# plot of fitting values
reg_arima_fit <- ts(reg_arima_btc$fitted,frequency = 365,
start = c(2016,1))
autoplot(cbind(btc_ts,reg_arima_fit),
main = "Regression + ARIMA Fit") +
labs("Series","Fit")
# plot of residuals vs. fitted values
library(ggplot2)
plot_resid_fit <- function(x,y,title) {
data = data.frame(x = x, y = y)
p <- ggplot(data, aes(x =  x, y = y)) +
geom_smooth(method = "lm", se=T,
col = "red",
formula = y ~ x,
show.legend = T) +
geom_point(alpha = 0.5,size = 2,
col = "black") +
xlab("Fit") + ylab("Residuals") +
ggtitle(glue("{title} Residuals vs Fit"))
return(p)
}
plot_resid_fit(fitted(reg_arima_btc),
resid(reg_arima_btc),"BTC")
#Plot recursive residuals
reg_arima_btc_recresid = recresid(reg_arima_btc$residuals~1)
plot(reg_arima_btc_recresid, ylab="Regression + Arima Fit",
main="Recursive Residuals from Regression + Arima Fit")
btc_eth_lm <- lm(btc$returns~eth$returns)
btc_lm_res_ts <- ts(btc_eth_lm$residuals,freq=365,start=c(2016,1))
reg_hw_btc <- hw(btc_lm_res_ts,seasonal=c("additive"))
View(returns)
reg_nnar_btc <- btc_eth_lm + nnetar(btc_eth_lm$residuals)
nnar_btc_res <- nnetar(btc_eth_lm$residuals)
reg_nnar_btc <- btch_eth_lm + nnar_btc_res
btc_eth_lm <- lm(returns$btc~returns$eth_ts)
nnar_btc_res <- nnetar(btc_eth_lm$residuals)
reg_nnar_btc <- btch_eth_lm + nnar_btc_res
reg_nnar_btc <- btc_eth_lm + nnar_btc_res
reg_nnar_btc <- nnetar(btc_eth_lm$residuals, xreg=btc_eth_lm)
reg_nnar_btc <- nnetar(btc_eth_lm$residuals,
xreg=cbing(returns$btc_ts,returns$eth_ts))
reg_nnar_btc <- nnetar(btc_eth_lm$residuals,
xreg=cbind(returns$btc_ts,returns$eth_ts))
nnar_btc <- nnetar(btc_ts)
#Try linear regression of btc~eth + nnetar(lm$resids)
btc_eth_lm <- lm(returns$btc~returns$eth_ts)
reg_nnar_btc <- nnetar(btc_eth_lm$residuals,
xreg=cbind(returns$btc_ts,returns$eth_ts))
autoplot(reg_nnar_btc)
ggplot(reg_nnar_btc)
plot(reg_nnar_btc)
autoplot(reg_nnar_btc$fitted)
autoplot(btc_ts) +
autolayer(nnar_btc$fitted, series="NNAR Model Returns") +
autolayer(reg_nnar_btc$fitted, series="LM of Returns + NNAR Model of Residuals") +
ggtitle("NNAR Model Fits for BTC Returns")
autoplot(btc_ts, series="BTC Returns") +
autolayer(nnar_btc$fitted, series="NNAR Model Returns") +
autolayer(reg_nnar_btc$fitted, series="LM of Returns + NNAR Model of Residuals") +
ggtitle("NNAR Model Fits for BTC Returns")
autoplot(nnar_btc$fitted, series="NNAR Model Returns")
autolayer(btc_ts, series="BTC Returns") +
autolayer(reg_nnar_btc$fitted, series="LM of Returns + NNAR Model of Residuals") +
ggtitle("NNAR Model Fits for BTC Returns")
autoplot(nnar_btc$fitted, series="NNAR Model Returns") +
autolayer(btc_ts, series="BTC Returns") +
autolayer(reg_nnar_btc$fitted, series="LM of Returns + NNAR Model of Residuals") +
ggtitle("NNAR Model Fits for BTC Returns")
autoplot(btc_ts, series="BTC Returns") +
autolayer(nnar_btc$fitted, series="NNAR Model Returns") +
autolayer(reg_nnar_btc$fitted, series="LM of Returns + NNAR Model of Residuals") +
ggtitle("NNAR Model Fits for BTC Returns")
checkresiduals(reg_nnar_btc$residuals)
checkresiduals(nnar_btc, main="Residuals from NNETAR Model of BTC Returns")
checkresiduals(reg_nnar_btc$residuals, main="Residuals from Linear Model with NNETAR Model of Residuals")
checkresiduals(reg_nnar_btc$residuals, main="Residuals from Linear Model with NNETAR Model of Residuals")
checkresiduals(nnar_btc, main="Residuals from NNETAR Model of BTC Returns")
checkresiduals(reg_nnar_btc$residuals, main="Residuals from Linear Model with NNETAR Model of Residuals")
plot_resid_fit(fitted(reg_nnar_btc),
resid(reg_nnar_btc),"BTC")
reg_nnar_btc_recresid = recresid(reg_nnar_btc$residuals~1)
plot(reg_nnar_btc_recresid,ylab="Regression + NNETAR Fit",
main="Recursive Residuals from Regression + NNETAR fit")
plot(efp(reg_nnar_btc_recresid,type="Rec-CUSUM")
plot(efp(reg_nnar_btc_recresid,type="Rec-CUSUM"))
plot(efp(reg_nnar_btc_recresid,type="Rec-CUSUM"))
plot(efp(reg_nnar_btc$residuals~1,type="Rec-CUSUM"))
reg_nnar_btc_recresid = recresid(reg_nnar_btc$residuals~1)
plot(reg_nnar_btc_recresid,ylab="Regression + NNETAR Fit",
main="Recursive Residuals from Regression + NNETAR fit")
reg_nnar_btc_fc <- forecast(reg_nnar_btc, h=12)
btc_tib %>%
model(reg_nnar_btc) %>%
forecast(h=12) %>%
autoplot(btc_ts)
reg_nnar_btc_fc <- forecast(nnar_btc, h=12)
autoplot(reg_nnar_btc_fc)
reg_nnar_btc_fc <- forecast(reg_nnar_btc, h=12)
reg_nnar_btc_pred <- predict(reg_nnar_btc, n.ahead=12)
ccf(btc_ts,eth_ts,ylab="Cross-Correlation Function", main = "BTC and ETH CCF")
y=cbind(btc_ts, eth_ts)
y_tot=data.frame(y)
VARselect(y_tot, lag.max = 20)
library(vars)
y=cbind(btc_ts, eth_ts)
y_tot=data.frame(y)
VARselect(y_tot, lag.max = 20)
y=cbind(btc_ts, eth_ts)
y_tot=data.frame(y)
VARselect(y_tot, lag.max = 10)
vmod_btc_eth=VAR(y_btc_eth,p=4)
y_btc_eth=cbind(btc_ts, eth_ts)
y_tot_btc_eth=data.frame(y_btc_eth)
VARselect(y_tot_btc_eth, lag.max = 10)
vmod_btc_eth=VAR(y_btc_eth,p=4)
summary(vmod_btc_eth)
ccf(btc_ts,xrp_ts,ylab="Cross-Correlation Function", main = "BTC and XRP CCF")
y_btc_xrp=cbind(btc_ts,xrp_ts)
y_tot_btc_xrp=data.frame(y_btc_xrp)
VARselect(y_btc_xrp, lag.max=10)
vmod_btc_xrp=VAR(y_btc_xrp,p=2)
summary(vmod_btc_xrp)
vmod_btc_eth$varresult$btc_ts
vmod_btc_eth$varresult$btc_ts
tsdisplay(vmod_btc_eth$varresult$btc_ts$fitted.values)
tsdisplay(vmod_btc_eth$varresult$btc_ts$residuals)
autoplot(btc_ts) +
autolayer(vmod_btc_eth$varresult$btc_ts$fitted.values, series="BTC Var Model")
plot(btc_ts)
lines(vmod_btc_eth$varresult$btc_ts$fitted.values)
autoplot(btc_ts) +
autolayer(vmod_btc_eth$varresult$btc_ts$fitted.values, series="BTC Var Model")
vmod_eth_ts = ts(vmod_btc_eth$varresult$btc_ts$fitted.values,
start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1)
lines(vmod_eth_ts,col="red",lty=2)
vmod_eth_ts = ts(vmod_btc_eth$varresult$btc_ts$fitted.values,
start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1,main="BTC Returns Fitted Values from BTC,ETH VAR Model")
lines(vmod_eth_ts,col="red",lty=2)
vmod_btc_xrp$varresult$btc_ts
tsdisplay(vmod_btc_xrp$varresult$btc_ts$fitted.values)
tsdisplay(vmod_btc_xrp$varresult$btc_ts$residuals)
#Plot Model
vmod_xrp_ts = ts(vmod_btc_xrp$varresult$btc_ts$fitted.values,
start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1,main="BTC Returns Fitted Values from BTC,XRP VAR Model")
lines(vmod_xrp_ts,col="red",lty=2)
vmod_xrp_ts = ts(vmod_btc_xrp$varresult$btc_ts$fitted.values,
start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1,main="BTC Returns Fitted Values from BTC,XRP VAR Model")
lines(vmod_xrp_ts,col="red",lty=2)
btc_tib <- as_tibble(btc)
btc_tib %>%
stretch_tsibble(.init = 10) %>%
model(
SES = ETS(returns$btc_ts ~ error("A") + trend("N") + season("N")),
Holt = ETS(returns$btc_ts ~ error("A") + trend("A") + season("N")),
additive = ETS(returns$btc_ts ~ error("A") + trend("A") + season("A")),
multiplicative = ETS(returns$btc_ts ~ error("M") + trend("A") + season("M"))
) %>%
forecast(h = 1) %>%
accuracy(btc_tib)
vmod_btc_eth$varresult$btc_ts
tsdisplay(vmod_btc_eth$varresult$btc_ts$fitted.values)
tsdisplay(vmod_btc_eth$varresult$btc_ts$residuals)
vmod_eth_ts = ts(vmod_btc_eth$varresult$btc_ts$fitted.values,
start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1,main="BTC Returns Fitted Values from BTC,ETH VAR Model")
lines(vmod_eth_ts,col="red",lty=2)
vmod_eth_ts = ts(vmod_btc_eth$varresult$btc_ts$fitted.values,
start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1,main="BTC Returns and Fitted Values from BTC,ETH VAR Model")
lines(vmod_eth_ts,col="red",lty=2)
legend("bottomleft",legend=c("BTC","VAR"),text.col=1:2,bty="n")
vmod_eth_ts = ts(vmod_btc_eth$varresult$btc_ts$fitted.values,
start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1,main="BTC Returns and Fitted Values from BTC,ETH VAR Model")
lines(vmod_eth_ts,col="red",lty=2)
legend("bottomleft",legend=c("BTC","VAR"),text.col=1:4,bty="n")
vmod_eth_ts = ts(vmod_btc_eth$varresult$btc_ts$fitted.values,
start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1,main="BTC Returns and Fitted Values from BTC,ETH VAR Model")
lines(vmod_eth_ts,col="red",lty=2)
legend("bottomleft",legend=c("BTC","VAR"),text.col=1:4,bty = "o")
vmod_xrp_ts = ts(vmod_btc_xrp$varresult$btc_ts$fitted.values,
start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1,main="BTC Returns Fitted Values from BTC,XRP VAR Model")
lines(vmod_xrp_ts,col="red",lty=2)
legend("bottomleft",legend=c("BTC","VAR"),text.col=1:4,bty = "o")
vmod_xrp_ts = ts(vmod_btc_xrp$varresult$btc_ts$fitted.values,
start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1,main="BTC Returns and Fitted Values from BTC,XRP VAR Model")
lines(vmod_xrp_ts,col="red",lty=2)
legend("bottomleft",legend=c("BTC","VAR"),text.col=1:4,bty = "o")
View(btc)
library(ModelMetrics)
btc.train <- window(btc_ts, end=c(2021,1))
xrp.train <- window(xrp_ts, end=c(2021,1))
y.xrp.train=cbind(btc.train,xrp.train)
y_xrp_train=data.frame(y.xrp.train)
vmod.xrp.train=VAR(y_xrp_train,p=2)
vmod.xrp.train.pred=predict(object=vmod.xrp.train, n.ahead=12)
mape(y_xrp_train$btc.train, vmod.xrp.train.pred$model$varresult$btc.train$fitted.values)
library(MLmetrics)
install.packages('MLmetrics')
library(MLmetrics)
mape(y_xrp_train$btc.train, vmod.xrp.train.pred$model$varresult$btc.train$fitted.values)
mape(y_xrp_train$btc.train, vmod.xrp.train.pred$model$varresult$btc.train$fitted.values)
MAPE(y_xrp_train$btc.train, vmod.xrp.train.pred$model$varresult$btc.train$fitted.values)
MAPE(y_xrp_train$btc.train, vmod.xrp.train.pred$model$varresult$btc.train$fitted.values)
library(MLmetrics)
btc.train <- window(btc_ts, end=c(2021,1))
xrp.train <- window(xrp_ts, end=c(2021,1))
y.xrp.train=cbind(btc.train,xrp.train)
y_xrp_train=data.frame(y.xrp.train)
vmod.xrp.train=VAR(y_xrp_train,p=2)
vmod.xrp.train.pred=predict(object=vmod.xrp.train, n.ahead=12)
MAPE(y_xrp_train$btc.train, vmod.xrp.train.pred$model$varresult$btc.train$fitted.values)
vmod_eth_ts = ts(vmod_btc_eth$varresult$btc_ts$fitted.values,
start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1,main="BTC Returns and Fitted Values from BTC,ETH VAR Model")
lines(vmod_eth_ts,col="red",lty=2)
legend("bottomleft",legend=c("BTC","VAR"),text.col=1:4,bty = "o")
vmod_btc_eth=VAR(y_btc_eth,p=4)
summary(vmod_btc_eth)
vmod_btc_eth$varresult$btc_ts
tsdisplay(vmod_btc_eth$varresult$btc_ts$fitted.values)
tsdisplay(vmod_btc_eth$varresult$btc_ts$residuals)
vmod_eth_ts = ts(vmod_btc_eth$varresult$btc_ts$fitted.values,
start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1,main="BTC Returns and Fitted Values from BTC,ETH VAR Model")
lines(vmod_eth_ts,col="red",lty=2)
legend("bottomleft",legend=c("BTC","VAR"),text.col=1:4,bty = "o")
vmod_btc_xrp$varresult$btc_ts
tsdisplay(vmod_btc_xrp$varresult$btc_ts$fitted.values)
tsdisplay(vmod_btc_xrp$varresult$btc_ts$residuals)
vmod_xrp_ts = ts(vmod_btc_xrp$varresult$btc_ts$fitted.values,
start=c(2016,1),freq=365)
plot(btc_ts,col="black",lwd=1,lty=1,main="BTC Returns and Fitted Values from BTC,XRP VAR Model")
lines(vmod_xrp_ts,col="red",lty=2)
legend("bottomleft",legend=c("BTC","VAR"),text.col=1:4,bty = "o")
MAPE(y_eth_train$btc.train, vmod.eth.train.pred$model$varresult$btc.train$fitted.values)
library(MLmetrics)
btc.train <- window(btc_ts, end=c(2021,1))
eth.train <- window(eth_ts, end=c(2021,1))
y.eth.train=cbind(btc.train,eth.train)
y_eth_train=data.frame(y.eth.train)
vmod.eth.train=VAR(y_eth_train,p=4)
vmod.eth.train.pred=predict(object=vmod.eth.train, n.ahead=12)
MAPE(y_eth_train$btc.train, vmod.eth.train.pred$model$varresult$btc.train$fitted.values)
MAPE(y_xrp_train$btc.train, vmod.xrp.train.pred$model$varresult$btc.train$fitted.values)
vmod.pred <- predict(object=vmod_btc_eth, n.ahead=12)
plot(vmod.pred)
vmod.pred <- predict(object=vmod_btc_eth, n.ahead=12)
plot(vmod.pred, xlim(2000,2500))
vmod.pred <- predict(object=vmod_btc_eth, n.ahead=12)
plot(vmod.pred, xlim=x(2000,2500))
vmod.pred <- predict(object=vmod_btc_eth, n.ahead=12)
plot(vmod.pred, xlim=c(2000,2500))
plot(fevd(vmod_btc_eth,n.ahead=12))
vmod.pred <- predict(object=vmod_btc_eth, n.ahead=12)
plot(vmod.pred, xlim=c(2000,2500))
MAPE(y_eth_train$btc.train, vmod.eth.train.pred$model$varresult$btc.train$fitted.values)
MAPE(y_xrp_train$btc.train, vmod.xrp.train.pred$model$varresult$btc.train$fitted.values)
vmod.pred <- predict(object=vmod_btc_eth, n.ahead=12)
plot(vmod.pred, xlim=c(2000,2500))
nnar_btc <- nnetar(btc_ts)
reg_nnar_btc <- nnetar(btc_eth_lm$residuals,
xreg=cbind(returns$btc_ts,returns$eth_ts))
autoplot(btc_ts, series="BTC Returns") +
autolayer(nnar_btc$fitted, series="NNAR Model Returns") +
autolayer(reg_nnar_btc$fitted, series="LM of Returns + NNAR Model of Residuals") +
ggtitle("NNAR Model Fits for BTC Returns")
checkresiduals(nnar_btc, main="Residuals from NNETAR Model of BTC Returns")
checkresiduals(reg_nnar_btc$residuals, main="Residuals from Linear Model with NNETAR Model of Residuals")
autoplot(btc_ts, series="BTC Returns") +
autolayer(nnar_btc$fitted, series="NNAR Model Returns")
autolayer(reg_nnar_btc$fitted, series="LM of Returns + NNAR Model of Residuals") +
autoplot(btc_ts, series="BTC Returns") +
autolayer(nnar_btc$fitted, series="NNAR Model Returns") +
autolayer(reg_nnar_btc$fitted, series="LM of Returns + NNAR Model of Residuals") +
ggtitle("NNAR Model Fits for BTC Returns")
autoplot(btc_ts, series="BTC Returns") +
autolayer(nnar_btc$fitted, series="NNAR Model Returns") +
autolayer(reg_nnar_btc$fitted, series="LM of Returns + NNAR Model of Residuals") +
ggtitle("NNAR Model Fits for BTC Returns")
reg_nnar_btc <- nnetar(btc_eth_lm$residuals,
xreg=cbind(returns$btc_ts,returns$eth_ts))
autoplot(btc_ts, series="BTC Returns") +
autolayer(nnar_btc$fitted, series="NNAR Model Returns") +
autolayer(reg_nnar_btc$fitted, series="LM of Returns + NNAR Model of Residuals") +
ggtitle("NNAR Model Fits for BTC Returns")
reg_nnar_btc_recresid = recresid(reg_nnar_btc$residuals~1)
plot(reg_nnar_btc_recresid,ylab="Regression + NNETAR Fit",
main="Recursive Residuals from Regression + NNETAR fit")
plot(btc_eth_lm)
btc.train <- window(btc_ts, end=c(2021,1))
eth.train <- window(eth_ts, end=c(2021,1))
btc.eth.lm.train <- lm(btc.train ~ eth.train)
View(btc.eth.lm.train)
reg.nnar.train <- nnetar(btc.eth.lm.train$residuals,
xreg=cbind(btc.train,eth.train))
reg.nnar.pred <- predict(object=reg.nnar.train,n.ahead=12)
View(reg.nnar.train)
reg.nnar.pred <- predict(object=reg.nnar.train$fitted,n.ahead=12)
View(reg.nnar.train)
reg.nnar.pred <- predict(object=reg.nnar.train$model,n.ahead=12)
reg.nnar.pred <- predict(object=reg.nnar.train$series,n.ahead=12)
reg.nnar.pred <- predict(object=reg.nnar.train$series)
reg.nnar.pred <- predict(object=reg.nnar.train$nnetargs, n.ahead=12)
reg.nnar.pred <- predict(object=reg.nnar.train$x, n.ahead=12)
reg.nnar.train.fit <- ts(reg.nnar.train$fitted,frequency=365,start = c(2016,1))
reg.nnar.pred <- predict(object=reg.nnar.train.fit, n.ahead=12)
reg.nnar.fc <- forecast(reg.nnar.train, h=12, PI=TRUE)
library(MLmetrics)
btc.train <- window(btc_ts, end=c(2021,1))
eth.train <- window(eth_ts, end=c(2021,1))
btc.eth.lm.train <- lm(btc.train ~ eth.train)
reg.nnar.train <- nnetar(btc.eth.lm.train$residuals,
xreg=cbind(btc.train,eth.train))
reg.nnar.pred <- predict(object=reg.nnar.train$fitted, n.ahead=12)
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
library(tseries)
library(forecast)
library(stats)
library(stats4)
library(TSA)
library(timeSeries)
library(fUnitRoots)
library(fBasics)
library(tseries)
library(timsac)
library(TTR)
library(strucchange)
library(tis)
library(zoo)
library(gridExtra)
library(crypto2)
library(ggplot2)
library(PerformanceAnalytics)
library(tibble)
library(vars)
library(MLmetrics)
btc_tib <- as_tibble(btc)
btc_eth_lm <- lm(btc$returns~eth$returns)
MAPE(vmod.eth.train.pred$model$varresult$btc.train$fitted.values, y_eth_train$btc.train)
